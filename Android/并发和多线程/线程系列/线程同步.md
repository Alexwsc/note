

# 线程同步



## 什么是线程同步



多个线程访问同一份资源（共享资源）的时候，线程之间相同协调的过程称为线程同步。



## synchronized 互斥锁（某一个时间段， 只有一个线程能够进入该代码块内）

synchronized(this) 锁定当前对象， 即持有当前对象的锁对象。

也可以给方法加 synchronized 关键字， 代表在执行这个方法的过程中， 锁定当前对象。

sleep()方法， 睡眠过程中， 并不释放当前持有的锁。



synchronized， 锁定一段代码。含义是：当执行这段代码的过程中， 锁定某个对象，其他线程如果也想执行这段代码，只能等着。等到之前那个线程持有的锁被释放，才能持有这个锁，然后i执行。



## 死锁



原理：



模拟死锁：





解决死锁的办法：

最好只锁定一个， 不要锁定多个（粒度加粗）


只读锁

只写锁

可重入锁

## 保护

要保护好需要同步的对象， 需要对 **访问共享资源的所有方法**  都要考虑  是否需要加入锁。

别的线程可以自由访问非同步的方法。	可能会对同步的方法产生影响。


## 生产者和消费者



做馒头   吃馒头

做馒头的做熟了馒头，仍在框里。吃馒头的人，从框里拿出来，吃馒头。



多个人做馒头。

多个人吃馒头。





封装



馒头

```java
class WoTou{
}
```





存放馒头的大筐。先放进去的后拿出来， 用栈来模拟。

```
class SyncTask{
int index = 0；


public void push(WoTou wt){
arrWT[index] = wt;
index ++;
}
}
```



index 栈顶指针。

拿馒头吃的人，和做馒头的人，都是一个线程。

当你调用push方法向筐里扔馒头的时候，，刚  arrWT[index] = wt;  完之后，被打断了。 	index 还没来得及++。下一个做馒头的人也往里面扔。就把上面的给覆盖了。解决这个问题的关键在于这两条语句之间不能被打断，要sync





篮子满了怎么办？

等着，等篮子里的馒头被吃掉了。

if (index  == arr.length) {

this.wait();

}





为什么用while 不用if

如果wait的过程被打断。

try{

this.wait

}catch（Exception e） {

e.prinf（（）；}

如果被打断， 就跳出了if，继续下面的执行。如果此时还是满的呢？ 就有问题了。

所以要用while。

即便是发生了Exception， 仍要要回头先检查是否已经满了， 如果满了， 还要继续wait。





这个wait 是Object里的wait

this.wait是啥意思?  是指当前执行这个代码块的线程wait

一个线程访问push方法的时候， 已经拿到了锁了。在它执行的过程中，遇到一个事件，必须阻塞。也就是做馒头的人，在往篮子里扔的时候，先检查了一下篮子满了，他就只能等着了。不能再往里扔了，再扔就冒出来了。要等到有人吃了，才能再继续往里扔。



只有持有了锁，才有资格wait。如果你压根拿不到锁，就根本无法wait。



何时醒来？









```
class Producer implements Runnable{
SyncStack ss  = null;
Producer（SyncStack ss）{
this.ss = ss;
}
}
```

生产者（做馒头的人）要往哪个筐里扔馒头，要知道。所以要持有筐的引用。

当创建生产者的时候，就告诉他要往哪个框里扔。因此我们提供一个构造方法，为SyncStack赋值



生产的过程， run方法



```
run(){
for (int i =0; i<20; i++) {
WoTou wt = new WoTou(i);
ss.push();
}
}
```





消费者， 吃窝头的人



```
class Consumer{

}
```





需要告诉从哪个筐里拿馒头吃。所以也要持有筐的引用。



消费的过程， run方法

一个人最多吃20个馒头

```
run(){

for (int i=0;i<20;i++){
WoTou wt = ss.pop();
SYstem.out.println(wt  被吃掉啦。)
}

}
```







吃馒头的人在从篮子中取得过程中， 也要判断篮子里是否还有馒头。如果篮子已经空了， 也要等待。

if（index == 0） {

wait

 }





wait 跟 sleep区别



1.wait 是Object 的   shleep 是Thread的。



2.wait的时候不再持有那个锁。等醒来才重新获取锁

sleep是睡着了也要抱着锁，不释放。

3.调用wait的时候必须锁定对象



this.nofity()

唤醒一个当前正在wait在当前对象的线程。





wait

notify

nofityALl

if while

sync 